<?php

namespace mcpepc\pocketmusic\tasks;

use ArrayObject;
use ZipArchive;
use mcpepc\pocketmusic\PocketMusic;
use pocketmine\resourcepacks\ResourcePackException;
use pocketmine\resourcepacks\ResourcePackManager;
use pocketmine\scheduler\Task;
use pocketmine\utils\UUID;
use function array_key_exists;
use function array_merge;
use function date;
use function dirname;
use function file_exists;
use function is_file;
use function json_encode;
use function preg_match;
use function rename;
use function unlink;
use const DATE_ATOM;

class ResourcePackCreationTask extends Task {
	private $filename;
	private $owningPlugin;
	private $zip;

	function __construct(PocketMusic $plugin) {
		$this->owningPlugin = $plugin;
		$this->filename = $plugin->getServer()->getResourcePackManager()->getPath() . $this->owningPlugin->getName() . '.' . UUID::fromRandom()->toString() . '.tmp.zip';
	}

	function onRun(int $currentTick) {
		$logger = $this->owningPlugin->getLogger();
		$zip = new ZipArchive;
		$this->zip = &$zip;

		if (($errorCode = $zip->open($this->filename, ZipArchive::CREATE)) !== true) {
			throw new ResourcePackException('[' . $this->owningPlugin->getName() . '] Could not open resource pack: ' . self::getZipArchiveErrorMessage($errorCode) . ', please retry later');
		}

		$zip->setArchiveComment('Generated by ' . $this->owningPlugin->getName() . ' on ' . date(DATE_ATOM));

		$jsonBitmask = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES;

		$config = $this->owningPlugin->getManifestConfig();
		$configDefaults = $this->owningPlugin->getManifestConfigDefaults();

		$name = $config->get('name', $configDefaults['name']);
		$extras = $config->get('extras', $configDefaults['extras']);
		$formatVersion = array_key_exists('format_version', $extras) ? $extras['format_version'] : 1;
		$version = [$formatVersion, 0, $config->get('version', $configDefaults['version'])];

		$manifest = array_merge($extras,
		[
			'format_version' => $formatVersion,
			'header' => array_merge(
				[
					'description' => 'Powered by ' . $this->owningPlugin->getName(),
					'name' => $name,
					'uuid' => $config->get('addonUUID'),
					'version' => $version
				], $extras['header'] ?? []),
			'modules' => array_merge(
				[
					[
						'description' => $name,
						'type' => 'resources',
						'uuid' => $config->get('resourcesUUID'),
						'version' => $version
					]
			], $extras['modules'] ?? [])
		]);
		$zip->addFromString('manifest.json', json_encode($manifest, $jsonBitmask));

		$soundDefinitions = [
			PocketMusic::RANDOM => [
				'category' => 'music',
				'sounds' => []
			]
		];
		foreach ($this->owningPlugin->getSoundsConfig()->getAll() as $soundName => $soundConfig) {
			if (!preg_match('/^[a-z]+$/', $soundName)) {
				$logger->error('Skipping ' . $soundName . ': the sound name should have only consist of lower case');
				continue;
			}
			$fileName = $soundName . '.ogg';
			$soundSettings = $this->owningPlugin->getConfig()->get('default-settings');
			if ($soundConfig instanceof ArrayObject) {
				$fileName = $soundConfig['file'];
				$soundSettings = array_merge($soundSettings, $soundConfig['settings']);
			} else if (!is_int($soundConfig)) {
				$logger->warning($soundName . ': unexpected type ' . gettype('$soundConfig') . ', uses default values');
			}

			$extension = pathinfo($fileName, PATHINFO_EXTENSION);

			$filePath = $this->owningPlugin->getSoundsPath() . $fileName;
			$soundPath = 'sounds/' . PocketMusic::TOP_SPACE . '/' . $soundName . '.' . $extension;
			if (!is_file($filePath) || ($extension !== 'ogg' && $extension !== 'fsb')) {
				$logger->error('Skipping $soundName: $fileName is not a file or not an accepted extension');
				continue;
			}
			$zip->addFile($filePath, $soundPath);
			$soundDefinitions[PocketMusic::MUSIC . $soundName] = [
				'category' => 'music',
				'sounds' => [
					array_merge(
						[
							'name' => ''
						],
						$soundSettings,
						[
							'name' => $soundPath
						]
					)
				]
			];
			$logger->info('Successfully added ' . $soundName);
		}

		foreach ($soundDefinitions as $soundName => $soundInfo) {
			$soundDefinitions[PocketMusic::RANDOM]['sounds'] = array_merge($soundDefinitions[PocketMusic::RANDOM]['sounds'], $soundInfo['sounds']);
		}

		$zip->addFromString('sounds/sound_definitions.json', json_encode($soundDefinitions, $jsonBitmask));

		$zip->close();
		$config->set('version', $version[2] + 1);

		$zipFileName = $this->owningPlugin->getServer()->getResourcePackManager()->getPath() . $this->owningPlugin->getName() . '.zip';
		if (file_exists($zipFileName)) {
			rename($zipFileName, $zipFileName . '.old.' . date('Ymd'));
		}
		rename($this->filename, $zipFileName);

		$logger->info('Resource pack successfully created. Please restart the server.');
	}

	function onCancel() {
		$this->zip->close();
		unlink($this->filename);
	}

	static function getZipArchiveErrorMessage(int $errorCode): string {
		switch ($errorCode) {
			case ZipArchive::ER_EXISTS:
				return 'File already exists';
			case ZipArchive::ER_INCONS:
				return 'Zip archive inconsistent';
			case ZipArchive::ER_INVAL:
				return 'Invalid argument';
			case ZipArchive::ER_MEMORY:
				return 'Malloc failure';
			case ZipArchive::ER_NOENT:
				return 'No such file';
			case ZipArchive::ER_NOZIP:
				return 'Not a zip archive';
			case ZipArchive::ER_OPEN:
				return 'Can\'t open file';
			case ZipArchive::ER_READ:
				return 'Read error';
			case ZipArchive::ER_SEEK:
				return 'Seek error';
		}
		return 'error code ' . $errorCode;
	}
}
