<?php

declare(strict_types=1);

namespace mcpepc\pocketmusic\tasks;

use ArrayObject;
use ZipArchive;
use mcpepc\pocketmusic\PocketMusic;
use pocketmine\plugin\Plugin;
use pocketmine\resourcepacks\ResourcePackException;
// use pocketmine\scheduler\AsyncTask; // TODO: Make ResourcePackCreationTask async
use pocketmine\utils\UUID;
use function array_key_exists;
use function array_merge;
use function date;
use function file_exists;
use function is_file;
use function json_encode;
use function preg_match;
use function rename;
use function unlink;
use const DATE_ATOM;

class ResourcePackCreationTask extends PocketMusicTask {
	private $filename;
	private $zip;

	function __construct(Plugin $plugin) {
		$this->owningPlugin = $plugin;
		$this->filename = $plugin->getServer()->getResourcePackManager()->getPath() . $this->getPlugin()->getName() . '.' . UUID::fromRandom()->toString() . '.tmp.zip';
	}

	function onRun(int $currentTick) {
		$logger = $this->getPlugin()->getLogger();
		$zip = new ZipArchive;
		$this->zip = $zip;

		if (($errorCode = $zip->open($this->filename, ZipArchive::CREATE)) !== true) {
			throw new ResourcePackException('[' . $this->getPlugin()->getName() . '] Could not open resource pack: ' . self::getZipArchiveErrorMessage($errorCode) . ', please retry later');
		}

		$zip->setArchiveComment('Generated by ' . $this->getPlugin()->getName() . ' on ' . date(DATE_ATOM));

		$jsonOptions = JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE;

		$config = $this->getPlugin()->getResourcePackConfig();
		$configDefaults = $this->getPlugin()->getResourcePackConfigDefaults();

		$config->set('soundsCache', []);

		$name = $config->get('name', $configDefaults['name']);
		$extras = $config->get('manifestExtras', $configDefaults['manifestExtras']);
		$formatVersion = array_key_exists('format_version', $extras) ? $extras['format_version'] : 1;
		$version = [$formatVersion, 0, $config->get('version', $configDefaults['version'])];

		$manifest = array_merge($extras,
		[
			'format_version' => $formatVersion,
			'header' => array_merge(
				[
					'description' => 'Powered by ' . $this->getPlugin()->getName(),
					'name' => $name,
					'uuid' => $config->getNested('uuid.addon', $configDefaults['uuid']['addon']),
					'version' => $version
				], $extras['header'] ?? []),
			'modules' => array_merge(
				[
					[
						'description' => $name,
						'type' => 'resources',
						'uuid' => $config->getNested('uuid.resources', $configDefaults['uuid']['resources']),
						'version' => $version
					]
			], $extras['modules'] ?? [])
		]);
		$zip->addFromString('manifest.json', json_encode($manifest, $jsonOptions));

		$soundDefinitions = [
			PocketMusic::RANDOM => [
				'category' => 'music',
				'sounds' => []
			]
		];
		foreach ($this->getPlugin()->getSoundsConfig()->getAll() as $soundName => $soundConfig) {
			if (!preg_match('/^[a-z]+$/', $soundName)) {
				$logger->error('Skipping ' . $soundName . ': the sound name should have only consist of lower case');
				continue;
			}
			$fileName = $soundName . '.ogg';
			$soundSettings = $this->getPlugin()->getConfig()->get('default-settings');
			if ($soundConfig instanceof ArrayObject) {
				$fileName = $soundConfig['file'];
				$soundSettings = array_merge($soundSettings, $soundConfig['settings']);
			} else if (!is_int($soundConfig)) {
				$logger->warning($soundName . ': unexpected type ' . gettype('$soundConfig') . ', uses default values');
			}

			$extension = pathinfo($fileName, PATHINFO_EXTENSION);

			$filePath = $this->getPlugin()->getSoundsPath() . $fileName;
			$soundPathName = 'sounds/' . PocketMusic::TOP_SPACE . '/' . $soundName;
			if (!is_file($filePath) || ($extension !== 'ogg' && $extension !== 'fsb')) {
				$logger->error('Skipping ' . $soundName . ': ' . $fileName . ' is not a file or not an accepted extension');
				continue;
			}

			$soundPath = $soundPathName . '.' . $extension;
			$zip->addFile($filePath, $soundPath);
			$zip->setCompressionName($soundPath, ZipArchive::CM_DEFLATE, $config->get('compressionLevel', $configDefaults['compressionLevel']));

			$soundDefinitions[PocketMusic::MUSIC . $soundName] = [
				'category' => 'music',
				'sounds' => [
					array_merge(
						[
							'name' => ''
						],
						$soundSettings,
						[
							'name' => $soundPathName
						]
					)
				]
			];
			$config->set('soundsCache', array_merge($config->get('soundsCache'), [$soundName]));

			$logger->info('Successfully added ' . $soundName);
		}

		foreach ($soundDefinitions as $soundName => $soundInfo) {
			$soundDefinitions[PocketMusic::RANDOM]['sounds'] = array_merge($soundDefinitions[PocketMusic::RANDOM]['sounds'], $soundInfo['sounds']);
		}

		$zip->addFromString('sounds/sound_definitions.json', json_encode($soundDefinitions, $jsonOptions));

		$zip->close();
		$config->set('version', $version[2] + 1);

		$zipFileName = $this->getPlugin()->getServer()->getResourcePackManager()->getPath() . $this->getPlugin()->getName() . '.zip';

		if (file_exists($zipFileName)) {
			rename($zipFileName, $zipFileName . '.old.' . date('YYYY-mm-dd_H:i:s'));
		}
		rename($this->filename, $zipFileName);

		$logger->info('Resource pack is created successfully');
		$logger->info('Please restart the server now');
	}

	function onCancel() {
		$this->zip->close();
		unlink($this->filename);
	}

	static function getZipArchiveErrorMessage(int $errorCode): string {
		$errors = [
			ZipArchive::ER_EXISTS => 'File already exists',
			ZipArchive::ER_INCONS => 'Zip archive inconsistent',
			ZipArchive::ER_INVAL => 'Invalid argument',
			ZipArchive::ER_MEMORY => 'Malloc failure',
			ZipArchive::ER_NOENT => 'No such file',
			ZipArchive::ER_NOZIP => 'Not a zip archive',
			ZipArchive::ER_OPEN => 'Can\'t open file',
			ZipArchive::ER_READ => 'Read error',
			ZipArchive::ER_SEEK => 'Seek error'
		];
		return $errors[$errorCode] ?? 'error code ' . $errorCode;
	}
}
